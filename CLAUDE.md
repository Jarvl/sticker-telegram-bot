# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

A Telegram bot that allows users to add images to configured sticker packs by replying to images with the "sticker" command. The bot supports both polling and webhook modes and can operate in both private chats and group conversations.

## Development Commands

### Setup and Installation
```bash
poetry install              # Install dependencies
make setup                  # Initial setup with pyenv check
make check-config           # Validate configuration only
```

### Running the Bot
```bash
make run                    # Run bot in mode specified by MODE env variable
poetry run python -m sticker_telegram_bot.main --config-check  # Config check only
```

### Code Quality
```bash
make format                 # Format code with black (line-length 88)
make lint                   # Run flake8 linter
poetry run black .          # Format code directly
poetry run flake8 .         # Lint directly
```

### Docker
```bash
make docker-build           # Build Docker image
make docker-run             # Run with Docker Compose
make docker-stop            # Stop containers
make logs                   # View Docker logs
```

### Cleanup
```bash
make clean                  # Clean Python cache and logs
```

## Architecture

### Core Components

**sticker_telegram_bot/config.py**
- Centralized configuration using environment variables
- Uses pydantic-like validation with `Config.validate()` class method
- All config is loaded from `.env` file via python-dotenv
- Supports optional `ALLOWED_CHAT_IDS` for restricting bot access to specific chats/users

**sticker_telegram_bot/bot.py**
- Main `StickerBot` class containing all bot logic
- Uses python-telegram-bot v22.2 with async/await patterns
- Global singleton instance: `bot = StickerBot()`
- Handlers registered in `start()` method, then run via `run_polling()` or `run_webhook()`

**sticker_telegram_bot/main.py**
- Entry point that validates config and starts bot in appropriate mode
- Supports `--config-check` flag for configuration validation
- Mode selection based on `Config.MODE` environment variable

### Bot Workflow

1. **Image Submission Flow**:
   - User replies to an image with `/sticker` command OR sends direct image (if allowed chat)
   - Bot extracts file_id and stores in `pending_stickers` dict keyed by user_id
   - Bot prompts user for emoji
   - User sends emoji response (validated with `emoji.is_emoji()`)
   - Bot presents inline keyboard with available sticker packs
   - User selects pack via callback query
   - Bot processes image (resize to 512x512, RGBA, centered on transparent canvas)
   - Bot adds sticker to pack (creates pack if doesn't exist)

2. **State Management**:
   - `pending_stickers` dict tracks user submissions with structure:
     ```python
     {
       user_id: {
         "message_id": int,
         "file_id": str,
         "chat_id": int,
         "user_message_id": int,
         "waiting_for_emoji": bool,
         "emoji": str  # added after emoji response
       }
     }
     ```
   - Use `/cancel` command to clear pending state

3. **Access Control**:
   - `is_chat_allowed()`: Checks if chat_id is in ALLOWED_CHAT_IDS (or allows all if None)
   - `is_direct_message_allowed()`: Additionally checks chat_id > 0 (positive = DM, negative = group)
   - Direct image handling only works in allowed DMs

4. **Callback Data Format**:
   - Pack selection buttons use format: `pack_{pack_name}|{user_id}`
   - Validated in `handle_sticker_pack_selection()` to prevent unauthorized access

### Image Processing

Images are processed in `process_image_for_sticker()`:
- Convert to RGBA mode
- Resize maintaining aspect ratio (max 512px on any side)
- Center on 512x512 transparent canvas using PIL
- Output as PNG bytes

### Sticker Pack Naming

Sticker set names generated by `make_sticker_set_name()`:
- Sanitizes title (removes special chars, collapses spaces to underscores)
- Format: `{cleaned_title}_by_{bot_username}`
- Must start with a letter per Telegram requirements

## Configuration

Required environment variables:
- `TELEGRAM_BOT_TOKEN`: Bot token from @BotFather
- `TELEGRAM_BOT_USERNAME`: Bot username (without @)
- `STICKER_PACKS`: Comma-separated list of pack names
- `STICKER_PACK_OWNER_USER_ID`: Integer user ID that owns sticker packs

Optional environment variables:
- `ALLOWED_CHAT_IDS`: Comma-separated list of chat IDs (empty = allow all)
- `MODE`: "polling" or "webhook" (default: polling)
- `API_HOST`: Host for API server (default: 0.0.0.0)
- `API_PORT`: Port for API server (default: 8000)
- `WEBHOOK_URL`: Required if MODE=webhook

**Important**: When using Kubernetes secrets, ensure no extra whitespace/newlines in integer values to avoid `ValueError: invalid literal for int()` errors.

## Python Version

- Requires Python 3.11+ (specified in pyproject.toml)
- Project uses pyenv with version in `.python-version` file
- Managed with Poetry for dependencies

## Key Dependencies

- `python-telegram-bot` (v22.2): Async Telegram bot framework
- `pillow` (v11.3): Image processing
- `pydantic` (v2.11): Used for config validation patterns
- `emoji` (v2.14): Emoji validation
- `python-dotenv` (v1.1): Environment variable loading

## Notes for Development

- All bot message handlers are async functions using `async def`
- The bot uses a global singleton pattern: modifications to `StickerBot` affect the global `bot` instance
- Error messages use emojis and friendly language (e.g., "ðŸ—¿ Hey that's a nice sticker suggestion...")
- HTML formatting is used in success messages with fallback to plain text if parsing fails
- Logging is configured at INFO level with timestamp, name, level, and message format
